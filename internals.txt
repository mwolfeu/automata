graph: closeness to goal / instances of AD/DD in given run

how would the test work if you didnt know where goal was?

# at some point when multiple pre-goals exist so that goal can be achieved,
# the choice of algorithm will vary with the pre-goal.  we can choose the one most often true given our context.
# can also judge if the frequency of Trueness is above a threshold. if not, go random?

# when abs(t adGoalX - t adBotX) < abs(t-1 adGoalX - t-1 adBotX) or abs(t adGoalY - t adBotY) < abs(t-1 adGoalY - t-1 adBotY)
# assuming no abs() the working alg will be different depending on direction needed to get to goal (with different start points)
# what is alg for current situation?

# Success Algorithm without barriers
# (t
#   (t ((t-1 bx,gx greaterThan t True), (t op bxMinus1 t True), and t True), ((t-1 bx,gx lessThan t True),(t op bxPlus1 t True) and t True) or t True),
#   (t ((t-1 by,gy greaterThan t True), (t op byMinus1 t True), and t True), ((t-1 by,gy lessThan t True),(t op byPlus1 t True) and t True) or t True)
# or t True)
# need to take out t, t-1 and put in some time related test need to genericize vars

# the above would only be arrived at by combining algs from many runs from many start points
# you could only get 1 of the above if you are N, S, E, or W from goal
# you could only get 2 of the above if you are NE, NW, SE, or SW from goal
# how to combine winners from different runs?

# winning algs will have to be genericized ... what patterns to recognize?
# all innermost () will be reduced with vars %1, %2... %n  That way they can be simply text matched and made into pointers if need be
# it is the reduced/genericized algs that will be weighted
# Ex: taking actual time out and putting in a variable
# also added somehow to tests object 

# desirable algorithms will have to be reduced which means:
#   if two accomplish the same task the shorter one is better (longer prolly has extraneous data)
#   if two accomplish the same task but variables are switched out, find some way to just plug the vars into the pattern
#   test can be made to cut out elements of algorithm to see if it functions as well
#   pattern matching can be done for parts shared between different algorithms.  
#     if a part is used more than once you can replace the part with a pointer to the part

# make pointers only for derived tests
# make an argv argc action function that stores/runs strings: the strings are reduced/genericized notation for commands


v 0.1
 initial structure / concepts 

v 0.2 

timestate is:
 Array of timeSlots containing (truncated to smallest)
  Array of AD / DD objects (dataTypes.py)

all runs truncated to shortest. comparison will now be w/regard to distance from goal
Large bug fix: Bot was losing x,y type
cleaned up prettyPrint, policy, timeState

Optimization:
thread per-wave testing / comparison, graphing, runs
# append / sort is expensive, can bsearch through sorted lists if needed
# https://docs.python.org/2/library/timeit.html, 
# python3.4 -m cProfile '/home/ich/Desktop/Code/AI/src/main.py'
# python3 -m cprofilev '/home/ich/Desktop/Code/AI/src/main.py'     http://localhost:4000/?sort=time
# cython shm threading SHM_OPEN  makeArgCombos is a good candidate


v 0.3 
AD split into pAD and aAD for passive and active AD Ex: passive=this is my x,  active=i chose to do this
added Desire model
added Learn model
added ability to test DD against a timeSlot (want fulfillment)
added serializer -n- store
generated suggestions for chooser

TODO
need to somehow test for: i did see this variable, it is new, could / not run a test before
All tests need to be autogenerated / rated: only use most useful tests

when choosing an action see if AD are similar to any in store
  if so, do highest rated action   (also sometimes do random if you want to keep on learning)
  else random
when making DD write to store / promote / demote existing or new algs
demote some with time (forgetting)
  
Idea:
consider a binary form of timeState smaller/faster/more picklable
if you have no suggestions for current actions you need a way to see what algs you come closest to
need to demote similarly valued algs if they are complicated or go back in time, etc.
for future vermutung: The copy module includes 2 functions, copy() and deepcopy(), for duplicating existing objects.
